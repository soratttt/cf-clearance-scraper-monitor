const fs = require("fs");
function solveTurnstileMin({ url, proxy, siteKey }) {
  return new Promise(async (resolve, reject) => {
    if (!url) return reject("Missing url parameter");
    if (!siteKey) return reject("Missing siteKey parameter");

    let context = null;
    let contextClosed = false;

    try {
      // ä½¿ç”¨ä¸Šä¸‹æ–‡æ± è·å–ä¸Šä¸‹æ–‡
      if (global.contextPool && typeof global.contextPool.getContext === 'function') {
        context = await global.contextPool.getContext();
      } else {
        // å›é€€åˆ°ç›´æ¥åˆ›å»º
        context = await global.browser
          .createBrowserContext({
            proxyServer: proxy ? `http://${proxy.host}:${proxy.port}` : undefined,
          })
          .catch(() => null);
      }

      if (!context) return reject("Failed to create browser context");

      let isResolved = false;

      const closeContext = async () => {
        if (!contextClosed && context) {
          try {
            contextClosed = true;
            // ä½¿ç”¨ä¸Šä¸‹æ–‡æ± é‡Šæ”¾ä¸Šä¸‹æ–‡
            if (global.contextPool && typeof global.contextPool.releaseContext === 'function') {
              await global.contextPool.releaseContext(context);
            } else {
              // å›é€€åˆ°ç›´æ¥å…³é—­
              await context.close();
            }
          } catch (err) {
            console.error("Error releasing context:", err.message);
          }
        }
      };

      var cl = setTimeout(async () => {
        if (!isResolved) {
          await closeContext();
          reject("Timeout Error");
        }
      }, global.timeOut || 180000);
      const page = await context.newPage();

      if (proxy?.username && proxy?.password)
        await page.authenticate({
          username: proxy.username,
          password: proxy.password,
        });

      await page.setRequestInterception(true);

      page.on("request", async (request) => {
        if (
          [url, url + "/"].includes(request.url()) &&
          request.resourceType() === "document"
        ) {
          await request.respond({
            status: 200,
            contentType: "text/html",
            body: String(
              require("fs").readFileSync(require("path").join(__dirname, "../data/fakePage.html"))
            ).replace(/<site-key>/g, siteKey),
          });
        } else {
          await request.continue();
        }
      });

      // ä¼˜åŒ–é¡µé¢åŠ è½½å’Œtokenç­‰å¾…
      await page.goto(url, {
        waitUntil: "domcontentloaded",
        timeout: 30000
      });

      // ä¼˜åŒ–çš„tokenç­‰å¾…é€»è¾‘ï¼Œå‡å°‘é˜»å¡æ—¶é—´
      let token = null;
      const maxAttempts = 2; // å‡å°‘é‡è¯•æ¬¡æ•°ï¼Œæé«˜å¹¶å‘
      const baseTimeout = 45000; // å‡å°‘åŸºç¡€è¶…æ—¶åˆ°45ç§’
      
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          console.log(`ğŸ”„ Turnstile attempt ${attempt}/${maxAttempts} for ${new URL(url).hostname}`);
          
          // å¹¶è¡Œç­‰å¾…Turnstileè„šæœ¬å’Œtoken
          const tokenPromise = page.waitForSelector('[name="cf-response"]', {
            timeout: baseTimeout + (attempt * 5000) // è¾ƒå°çš„é€’å¢æ—¶é—´
          });
          
          const scriptPromise = page.waitForFunction(() => {
            return window.turnstile && typeof window.turnstile.render === 'function';
          }, { timeout: 10000 }).catch(() => {
            console.log('âš ï¸  Turnstile script not loaded quickly, continuing...');
          });
          
          // å¹¶è¡Œç­‰å¾…ï¼Œæé«˜æ•ˆç‡
          await Promise.race([
            tokenPromise,
            scriptPromise.then(() => tokenPromise)
          ]);
          
          // å¿«é€ŸéªŒè¯token
          token = await page.evaluate(() => {
            const element = document.querySelector('[name="cf-response"]');
            const value = element?.value;
            
            // ä¼˜åŒ–çš„tokenéªŒè¯
            if (value && value.length > 10 && 
                !value.includes('undefined') && 
                !value.includes('null') &&
                value.indexOf('.') > 0) { // Turnstile tokené€šå¸¸åŒ…å«ç‚¹
              return value;
            }
            return null;
          });
          
          if (token) {
            console.log(`âœ… Turnstile token obtained on attempt ${attempt} (${token.length} chars)`);
            break;
          } else {
            console.log(`âŒ Invalid token on attempt ${attempt}, retrying...`);
            if (attempt < maxAttempts) {
              // æ›´çŸ­çš„ç­‰å¾…æ—¶é—´
              await new Promise(resolve => setTimeout(resolve, 1000));
              // å¿«é€Ÿåˆ·æ–°
              await page.reload({ waitUntil: 'domcontentloaded', timeout: 15000 });
            }
          }
          
        } catch (attemptError) {
          console.log(`âŒ Attempt ${attempt} failed: ${attemptError.message}`);
          if (attempt === maxAttempts) {
            throw attemptError;
          }
          // æ›´å¿«çš„å¤±è´¥æ¢å¤
          await page.reload({ waitUntil: 'domcontentloaded', timeout: 15000 }).catch(() => {});
          await new Promise(resolve => setTimeout(resolve, 1500));
        }
      }
      
      isResolved = true;
      clearTimeout(cl);
      await closeContext();
      if (!token || token.length < 10) return reject("Failed to get token");
      return resolve(token);
      
    } catch (e) {
      console.log(e);
      isResolved = true;
      clearTimeout(cl);
      if (context && !contextClosed) {
        try {
          contextClosed = true;
          await context.close();
        } catch (err) {
          console.error("Error closing context:", err.message);
        }
      }
      reject(e.message);
    }
  });
}
module.exports = solveTurnstileMin;