<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ¬åœ°æ‰“ç æœåŠ¡ç›‘æ§</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>æœ¬åœ°æ‰“ç æœåŠ¡ç›‘æ§</h1>
        </div>

        <div class="dashboard">
            <!-- å¯ç”¨æœåŠ¡å¡ç‰‡ -->
            <div class="card">
                <h3><span class="icon">ğŸ› ï¸</span>å¯ç”¨æœåŠ¡</h3>
                <div id="serviceStatus" class="loading">åŠ è½½ä¸­...</div>
            </div>

            <!-- å®ä¾‹ä¿¡æ¯å¡ç‰‡ -->
            <div class="card">
                <h3><span class="icon">ğŸ–¥ï¸</span>å®ä¾‹ä¿¡æ¯</h3>
                <div id="instanceInfo" class="loading">åŠ è½½ä¸­...</div>
            </div>

            <!-- è¯·æ±‚ç»Ÿè®¡å¡ç‰‡ -->
            <div class="card">
                <h3><span class="icon">ğŸ“Š</span>è¯·æ±‚ç»Ÿè®¡</h3>
                <div id="requestStats" class="loading">åŠ è½½ä¸­...</div>
            </div>

            <!-- ç³»ç»Ÿèµ„æºå¡ç‰‡ -->
            <div class="card">
                <h3><span class="icon">âš™ï¸</span>ç³»ç»Ÿèµ„æº</h3>
                <div id="systemResources" class="loading">åŠ è½½ä¸­...</div>
            </div>

            <!-- è´Ÿè½½å†å²å›¾è¡¨ -->
            <div class="card load-history-card" style="grid-column: 1 / -1;">
                <h3>
                    <span class="icon">ğŸ“Š</span>è´Ÿè½½å†å²
                    <span class="live-indicator">å®æ—¶ 1s</span>
                </h3>
                <div class="metrics-summary" id="metricsSummary" style="display: flex; gap: 20px; margin-bottom: 10px; flex-wrap: wrap;">
                    <div class="metric-item">
                        <span class="metric-label">å½“å‰æ´»è·ƒ</span>
                        <span class="metric-value" id="currentActive">0</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">å³°å€¼å¹¶å‘</span>
                        <span class="metric-value" id="peakConcurrent">0</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">å¹³å‡è´Ÿè½½</span>
                        <span class="metric-value" id="avgLoad">0.0</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">æ€»å®¹é‡</span>
                        <span class="metric-value" id="totalCapacity">100</span>
                    </div>
                </div>
                <div class="chart-container load-chart-container">
                    <canvas id="loadHistoryChart" class="chart-canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- è¯·æ±‚å†å²ä¸å®æ—¶çŠ¶æ€ -->
        <div class="table-container">
            <h3>
                <span class="icon">ğŸ“‹</span>è¯·æ±‚è®°å½•ä¸å®æ—¶çŠ¶æ€ 
                <button class="btn" onclick="resetMonitorData()">é‡ç½®æ•°æ®</button>
                <span class="live-indicator">å®æ—¶æ›´æ–°</span>
            </h3>
            <div id="unifiedRequestTable" class="loading">åŠ è½½ä¸­...</div>
        </div>

        <div class="footer">
            <div style="display: flex; justify-content: center; align-items: center; gap: 30px;">
                <span>
                    Designed by <a href="https://x.com/Johnze268" target="_blank">
                        <img src="https://abs.twimg.com/favicons/twitter.2.ico" alt="Twitter"> 0xsongsu
                    </a>
                </span>
                <span>
                    Powered by <a href="https://claude.ai" target="_blank">
                        <img src="https://claude.ai/favicon.ico" alt="Claude">
                    </a>
                </span>
            </div>
        </div>
    </div>

    <script src="charts.js"></script>
    <script>
        let updateInterval;
        let loadChart = null;
        let loadHistory = [];
        let peakConcurrent = 0;
        
        // åˆå§‹åŒ–å›¾è¡¨
        function initCharts() {
            const canvas = document.getElementById('loadHistoryChart');
            if (canvas) {
                loadChart = new LoadHistoryChart(canvas, {
                    backgroundColor: '#f8f9fa',
                    fillColor: 'rgba(52, 144, 220, 0.2)',
                    lineColor: 'rgba(52, 144, 220, 1)',
                    lineWidth: 2,
                    maxDataPoints: 60
                });
            }
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(timestamp) {
            return new Date(timestamp).toLocaleString('zh-CN');
        }

        // æ ¼å¼åŒ–æŒç»­æ—¶é—´
        function formatDuration(ms) {
            if (ms < 1000) return `${ms}ms`;
            if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
            if (ms < 3600000) return `${(ms / 60000).toFixed(1)}m`;
            return `${(ms / 3600000).toFixed(1)}h`;
        }

        // æ ¼å¼åŒ–å†…å­˜å¤§å°
        function formatMemory(mb) {
            if (mb < 1024) return `${mb}MB`;
            return `${(mb / 1024).toFixed(1)}GB`;
        }

        // è·å–ç›‘æ§æ•°æ®
        async function fetchMonitorData() {
            try {
                let response = await fetch('/api/monitor');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                updateDashboard(data);
                
            } catch (error) {
                console.error('è·å–ç›‘æ§æ•°æ®å¤±è´¥:', error);
                showError('è·å–ç›‘æ§æ•°æ®å¤±è´¥: ' + error.message);
            }
        }

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            
            // åœ¨æ¯ä¸ªloadingå…ƒç´ ä¸­æ˜¾ç¤ºé”™è¯¯
            document.querySelectorAll('.loading').forEach(element => {
                element.innerHTML = '';
                element.appendChild(errorDiv.cloneNode(true));
            });
        }

        // æ›´æ–°ä»ªè¡¨æ¿
        function updateDashboard(data) {
            updateServiceStatus(data);
            updateInstanceInfo(data);
            updateRequestStats(data);
            updateSystemResources(data);
            updateUnifiedRequestTable(data);
            updateLoadMetrics(data);
            updateCharts(data);
        }

        // æ›´æ–°æœåŠ¡çŠ¶æ€
        function updateServiceStatus(data) {
            const element = document.getElementById('serviceStatus');
            
            element.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="padding: 15px; background: rgba(28, 168, 221, 0.1); border-radius: 8px; text-align: center; border: 2px solid rgba(28, 168, 221, 0.2);">
                        <div style="margin-bottom: 10px;">
                            <img src="https://dash.cloudflare.com/favicon.ico" alt="Cloudflare" style="width: 32px; height: 32px;">
                        </div>
                        <div style="font-weight: bold; color: #1ca8dd; margin-bottom: 5px; font-size: 0.9rem;">Cloudflare</div>
                        <div style="color: #27ae60; font-size: 0.8rem; font-weight: 600;">
                            <span class="status-indicator status-running" style="margin-right: 4px;"></span>
                            è¿è¡Œä¸­
                        </div>
                    </div>
                    <div style="padding: 15px; background: rgba(255, 140, 0, 0.1); border-radius: 8px; text-align: center; border: 2px solid rgba(255, 140, 0, 0.2);">
                        <div style="margin-bottom: 10px;">
                            <img src="hcaptcha-logo.png" alt="hCaptcha" style="width: 32px; height: 32px;">
                        </div>
                        <div style="font-weight: bold; color: #ff8c00; margin-bottom: 5px; font-size: 0.9rem;">hCaptcha</div>
                        <div style="color: #27ae60; font-size: 0.8rem; font-weight: 600;">
                            <span class="status-indicator status-running" style="margin-right: 4px;"></span>
                            è¿è¡Œä¸­
                        </div>
                    </div>
                </div>
            `;
        }

        // æ›´æ–°å®ä¾‹ä¿¡æ¯
        function updateInstanceInfo(data) {
            const element = document.getElementById('instanceInfo');
            const usagePercent = data.instances.total > 0 ? 
                (data.instances.active / data.instances.total * 100).toFixed(1) : 0;
            
            let instanceDetailsHtml = '';
            
            // æ˜¾ç¤ºå„ä¸ªå®¹å™¨çš„è¯¦ç»†ä¿¡æ¯ï¼ˆå¦‚æœæœ‰å¤šå®¹å™¨éƒ¨ç½²ï¼‰
            if (data.containers && data.containers.length > 0) {
                instanceDetailsHtml = `
                    <div style="margin-top: 15px; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 15px;">
                        <h4 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #34495e;">å®¹å™¨è¯¦æƒ…</h4>
                        ${data.containers.map(container => `
                            <div style="margin-bottom: 8px; padding: 8px; background: rgba(255,255,255,0.5); border-radius: 4px; font-size: 0.8rem;">
                                <strong>${container.host}</strong>
                                <span style="float: right;">
                                    <span class="status-indicator status-running"></span>
                                    ${container.instances.total}å®ä¾‹ (${container.instances.active}æ´»è·ƒ/${container.instances.available}ç©ºé—²)
                                </span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // æ˜¾ç¤ºæµè§ˆå™¨å®ä¾‹æ± è¯¦æƒ…
            let browserPoolHtml = '';
            if (data.browserPoolDetails && data.browserPoolDetails.length > 0) {
                browserPoolHtml = `
                    <div style="margin-top: 15px; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 15px;">
                        <h4 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #34495e;">æµè§ˆå™¨å®ä¾‹æ± </h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px;">
                            ${data.browserPoolDetails.map(instance => `
                                <div style="padding: 8px; background: rgba(255,255,255,0.5); border-radius: 4px; text-align: center; font-size: 0.75rem;">
                                    <div style="font-weight: bold;">å®ä¾‹ #${instance.id}</div>
                                    <div style="margin: 2px 0;">
                                        <span class="status-indicator ${instance.status === 'idle' ? 'status-running' : 'status-warning'}"></span>
                                        ${instance.status === 'idle' ? 'ç©ºé—²' : 'å¿™ç¢Œ'}
                                    </div>
                                    <div style="color: #7f8c8d; font-size: 0.7rem;">
                                        ä¸Šä¸‹æ–‡: ${instance.contexts || 0}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            element.innerHTML = `
                <div class="stat-grid" style="grid-template-columns: 1fr 1fr;">
                    <div class="stat-item">
                        <div class="stat-value">${data.instances.active}</div>
                        <div class="stat-label">å¿™ç¢Œå®ä¾‹</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${data.instances.available}</div>
                        <div class="stat-label">ç©ºé—²å®ä¾‹</div>
                    </div>
                </div>
                <div style="margin-top: 15px; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 15px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #34495e;">æœåŠ¡å®ä¾‹åˆ†å¸ƒ</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div style="padding: 8px; background: rgba(28, 168, 221, 0.1); border-radius: 4px; text-align: center; font-size: 0.8rem;">
                            <div style="font-weight: bold; color: #1ca8dd; margin-bottom: 4px;">Cloudflare</div>
                            <div style="color: #7f8c8d;">å®ä¾‹: ${data.activeRequestsByService?.cloudflare || 0}</div>
                            <div style="color: #7f8c8d; font-size: 0.7rem;">Turnstile è§£å†³</div>
                        </div>
                        <div style="padding: 8px; background: rgba(255, 140, 0, 0.1); border-radius: 4px; text-align: center; font-size: 0.8rem;">
                            <div style="font-weight: bold; color: #ff8c00; margin-bottom: 4px;">hCaptcha</div>
                            <div style="color: #7f8c8d;">å®ä¾‹: ${data.activeRequestsByService?.hcaptcha || 0}</div>
                            <div style="color: #7f8c8d; font-size: 0.7rem;">AI è§£å†³</div>
                        </div>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${usagePercent}%"></div>
                </div>
                <div style="text-align: center; margin-top: 5px; font-size: 0.9rem; color: #7f8c8d;">
                    ä½¿ç”¨ç‡: ${usagePercent}%
                </div>
                ${instanceDetailsHtml}
                ${browserPoolHtml}
            `;
        }

        // æ›´æ–°è¯·æ±‚ç»Ÿè®¡
        function updateRequestStats(data) {
            const element = document.getElementById('requestStats');
            
            // æ›´æ–°å†å²æ•°æ®
            const now = new Date();
            historyData.activeRequests.push(data.requests.active);
            historyData.successRate.push(data.requests.successRate);
            
            // ä¿æŒæ•°æ®ç‚¹æ•°é‡ä¸è¶…è¿‡æœ€å¤§å€¼
            if (historyData.activeRequests.length > maxHistoryPoints) {
                historyData.activeRequests.shift();
                historyData.successRate.shift();
            }
            
            element.innerHTML = `
                <!-- é¢œè‰²å›¾ä¾‹ -->
                <div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 8px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 16px; height: 2px; background: #28a745;"></div>
                        <span style="color: #28a745; font-size: 0.8rem;">æ´»è·ƒè¯·æ±‚</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 16px; height: 2px; background: #ff6b6b;"></div>
                        <span style="color: #ff6b6b; font-size: 0.8rem;">æˆåŠŸç‡</span>
                    </div>
                </div>
                
                <!-- è¯·æ±‚ç»Ÿè®¡å›¾è¡¨ -->
                <div style="background: #1a1a1a; border-radius: 8px; padding: 12px; height: 180px; position: relative;">
                    <!-- ç»Ÿè®¡ä¿¡æ¯ï¼ˆå³ä¸Šè§’ï¼‰ -->
                    <div style="position: absolute; top: 12px; right: 12px; text-align: right; font-size: 0.7rem; color: #ffffff; line-height: 1.2; z-index: 10;">
                        <div style="color: #00ff88;">æ€»: ${data.requests.total}</div>
                        <div style="color: #00ddff;">æˆåŠŸ: ${data.requests.successful}</div>
                        <div style="color: #ff8888;">å¤±è´¥: ${data.requests.failed}</div>
                    </div>
                    
                    <!-- å›¾è¡¨ç”»å¸ƒï¼ˆèƒŒæ™¯ï¼‰ -->
                    <canvas id="requestChart" width="100" height="156" style="position: absolute; top: 12px; left: 12px; width: calc(100% - 24px); height: calc(100% - 24px); z-index: 1;"></canvas>
                    
                    <!-- å·¦ä¾§åˆ»åº¦ï¼ˆæ´»è·ƒè¯·æ±‚ï¼‰ -->
                    <div style="position: absolute; left: 8px; top: 50%; transform: translateY(-50%); color: #28a745; z-index: 10; font-size: 0.9rem; font-weight: bold;">${data.requests.active}</div>
                    
                    <!-- å³ä¾§åˆ»åº¦ï¼ˆæˆåŠŸç‡ï¼‰ -->
                    <div style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: #ff6b6b; text-align: right; z-index: 10; font-size: 0.9rem; font-weight: bold;">${data.requests.successRate}%</div>
                </div>
            `;
            
            // ç»˜åˆ¶åŒæŠ˜çº¿å›¾è¡¨
            setTimeout(() => {
                drawDualLineChart('requestChart', historyData.activeRequests, historyData.successRate, '#28a745', '#ff6b6b');
            }, 100);
        }

        // å†å²æ•°æ®å­˜å‚¨
        const historyData = {
            cpu: [],
            memory: [],
            activeRequests: [],
            successRate: [],
            timestamps: []
        };
        
        const maxHistoryPoints = 50; // ä¿ç•™æœ€è¿‘50ä¸ªæ•°æ®ç‚¹

        // æ›´æ–°ç³»ç»Ÿèµ„æºä¿¡æ¯
        function updateSystemResources(data) {
            const element = document.getElementById('systemResources');
            const memory = data.memory;
            
            // è®¡ç®—ä½¿ç”¨ç‡
            const cpuUsage = data.memory.cpu?.current || 0;
            const memoryUsage = (data.memory.system.used / data.memory.system.total) * 100;
            
            // æ›´æ–°å†å²æ•°æ®
            const now = new Date();
            historyData.cpu.push(cpuUsage);
            historyData.memory.push(memoryUsage);
            historyData.timestamps.push(now);
            
            // ä¿æŒæ•°æ®ç‚¹æ•°é‡ä¸è¶…è¿‡æœ€å¤§å€¼
            if (historyData.cpu.length > maxHistoryPoints) {
                historyData.cpu.shift();
                historyData.memory.shift();
                historyData.timestamps.shift();
            }
            
            element.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- CPU ä½¿ç”¨ç‡å›¾è¡¨ -->
                    <div style="background: #1a1a1a; border-radius: 8px; padding: 12px; height: 120px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #00ffff; font-size: 0.85rem; font-weight: 500;">CPU ä½¿ç”¨ç‡</span>
                            <span style="color: #00ffff; font-size: 0.9rem; font-weight: bold;">${cpuUsage.toFixed(1)}%</span>
                        </div>
                        <canvas id="cpuChart" width="100" height="80" style="width: 100%; height: 80px;"></canvas>
                    </div>
                    
                    <!-- ç³»ç»Ÿå†…å­˜è´Ÿè½½å›¾è¡¨ -->
                    <div style="background: #1a1a1a; border-radius: 8px; padding: 12px; height: 120px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: #00ffaa; font-size: 0.85rem; font-weight: 500;">ç³»ç»Ÿå†…å­˜è´Ÿè½½</span>
                            <span style="color: #00ffaa; font-size: 0.9rem; font-weight: bold;">${memoryUsage.toFixed(1)}%</span>
                        </div>
                        <canvas id="memoryChart" width="100" height="80" style="width: 100%; height: 80px;"></canvas>
                    </div>
                </div>
            `;
            
            // ç»˜åˆ¶å›¾è¡¨
            setTimeout(() => {
                drawChart('cpuChart', historyData.cpu, '#00ffff');
                drawChart('memoryChart', historyData.memory, '#00ffaa');
            }, 100);
        }

        // ç»˜åˆ¶æŠ˜çº¿å›¾å‡½æ•°
        function drawChart(canvasId, data, color) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            if (data.length < 2) return;
            
            // è®¾ç½®ç”»å¸ƒå¤§å°é€‚åº”å®¹å™¨ - æ”¯æŒé«˜DPI
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            ctx.scale(dpr, dpr);
            
            const w = rect.width;
            const h = rect.height;
            
            // è®¡ç®—æ•°æ®ç‚¹ä½ç½®
            const padding = 10;
            const chartWidth = w - padding * 2;
            const chartHeight = h - padding * 2;
            
            // Yè½´èŒƒå›´ï¼š1% åˆ° 100%
            const minY = 1;
            const maxY = 100;
            
            // åˆ›å»ºè·¯å¾„
            ctx.beginPath();
            
            // ç»˜åˆ¶å¡«å……åŒºåŸŸ
            const gradient = ctx.createLinearGradient(0, padding, 0, h - padding);
            gradient.addColorStop(0, color + '40'); // 40% é€æ˜åº¦
            gradient.addColorStop(1, color + '10'); // 10% é€æ˜åº¦
            
            // ç»˜åˆ¶æ•°æ®ç‚¹å’Œçº¿æ¡
            for (let i = 0; i < data.length; i++) {
                const x = padding + (i / (data.length - 1)) * chartWidth;
                const y = padding + (1 - (Math.max(data[i], minY) - minY) / (maxY - minY)) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    // ä½¿ç”¨è´å¡å°”æ›²çº¿åˆ›å»ºå¹³æ»‘çº¿æ¡
                    const prevX = padding + ((i - 1) / (data.length - 1)) * chartWidth;
                    const prevY = padding + (1 - (Math.max(data[i - 1], minY) - minY) / (maxY - minY)) * chartHeight;
                    
                    const cpx = prevX + (x - prevX) * 0.5;
                    const cpy = prevY;
                    const cpx2 = prevX + (x - prevX) * 0.5;
                    const cpy2 = y;
                    
                    ctx.bezierCurveTo(cpx, cpy, cpx2, cpy2, x, y);
                }
            }
            
            // ç»˜åˆ¶å¡«å……åŒºåŸŸ
            const fillPath = new Path2D();
            fillPath.moveTo(padding, h - padding); // åº•éƒ¨å·¦è¾¹
            
            for (let i = 0; i < data.length; i++) {
                const x = padding + (i / (data.length - 1)) * chartWidth;
                const y = padding + (1 - (Math.max(data[i], minY) - minY) / (maxY - minY)) * chartHeight;
                
                if (i === 0) {
                    fillPath.lineTo(x, y);
                } else {
                    const prevX = padding + ((i - 1) / (data.length - 1)) * chartWidth;
                    const prevY = padding + (1 - (Math.max(data[i - 1], minY) - minY) / (maxY - minY)) * chartHeight;
                    
                    const cpx = prevX + (x - prevX) * 0.5;
                    const cpy = prevY;
                    const cpx2 = prevX + (x - prevX) * 0.5;
                    const cpy2 = y;
                    
                    fillPath.bezierCurveTo(cpx, cpy, cpx2, cpy2, x, y);
                }
            }
            
            fillPath.lineTo(padding + chartWidth, h - padding); // åº•éƒ¨å³è¾¹
            fillPath.closePath();
            
            // å¡«å……åŒºåŸŸ
            ctx.fillStyle = gradient;
            ctx.fill(fillPath);
            
            // ç»˜åˆ¶çº¿æ¡
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }

        // æˆªæ–­tokenæ˜¾ç¤º
        function truncateToken(token, maxLength = 30) {
            if (!token || token.length <= maxLength) return token || '';
            return token.substring(0, maxLength) + '...';
        }

        // æ›´æ–°ç»Ÿä¸€è¯·æ±‚è¡¨æ ¼
        function updateUnifiedRequestTable(data) {
            const element = document.getElementById('unifiedRequestTable');
            const allRequests = [];
            
            // æ·»åŠ æ´»è·ƒè¯·æ±‚ï¼ˆå¤„ç†ä¸­çŠ¶æ€ï¼‰
            data.activeRequests.forEach(req => {
                allRequests.push({
                    timestamp: req.startTime,
                    url: req.url,
                    mode: req.mode,
                    status: 'processing',
                    token: '',
                    responseTime: Date.now() - new Date(req.startTime).getTime(),
                    isActive: true,
                    requestId: req.id,
                    clientIP: req.clientIP
                });
            });
            
            // æ·»åŠ è¯·æ±‚å†å²ï¼ˆå·²å®Œæˆ/å¤±è´¥çŠ¶æ€ï¼‰
            data.requestHistory.forEach(req => {
                // æŸ¥æ‰¾å¯¹åº”çš„token - åªæ ¹æ®requestIdåŒ¹é…ï¼Œé¿å…é‡å¤
                const matchingToken = data.recentTokens.find(token => 
                    token.requestId === req.requestId
                );
                
                allRequests.push({
                    timestamp: req.timestamp,
                    url: req.url,
                    mode: req.mode,
                    status: req.success ? 'completed' : 'failed',
                    token: matchingToken ? matchingToken.token : '',
                    responseTime: req.responseTime,
                    isActive: false,
                    requestId: req.requestId
                });
            });
            
            // æŒ‰æ—¶é—´å€’åºæ’åˆ—
            allRequests.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            if (allRequests.length === 0) {
                element.innerHTML = '<p style="text-align: center; color: #7f8c8d; padding: 20px;">æš‚æ— è¯·æ±‚è®°å½•</p>';
                return;
            }
            
            const tableHTML = `
                <table>
                    <thead>
                        <tr>
                            <th style="width: 120px;">æ—¶é—´</th>
                            <th style="width: 120px; max-width: 120px;">URL</th>
                            <th style="width: 100px;">æœåŠ¡</th>
                            <th style="width: 100px;">çŠ¶æ€</th>
                            <th style="width: 120px;">Token</th>
                            <th style="width: 90px;">å“åº”æ—¶é—´</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${allRequests.slice(0, 50).map(req => {
                            let statusDisplay = '';
                            let statusClass = '';
                            
                            switch(req.status) {
                                case 'processing':
                                    statusDisplay = 'å¤„ç†ä¸­';
                                    statusClass = 'status-warning';
                                    break;
                                case 'completed':
                                    statusDisplay = 'å·²å®Œæˆ';
                                    statusClass = 'status-running';
                                    break;
                                case 'failed':
                                    statusDisplay = 'å¤±è´¥';
                                    statusClass = 'status-error';
                                    break;
                            }
                            
                            const truncatedToken = truncateToken(req.token, 20);
                            const responseTimeDisplay = req.status === 'processing' 
                                ? `${formatDuration(req.responseTime)} â±ï¸`
                                : formatDuration(req.responseTime);
                            
                            // ç¡®å®šæœåŠ¡ç±»å‹
                            let serviceType = '';
                            let serviceColor = '';
                            if (req.mode === 'hcaptcha' || (req.url && req.url.includes('hcaptcha'))) {
                                serviceType = 'hCaptcha';
                                serviceColor = '#ff8c00';
                            } else {
                                serviceType = 'Cloudflare';
                                serviceColor = '#1ca8dd';
                            }
                            
                            return `
                                <tr class="${req.isActive ? 'active-request' : ''}" style="${req.isActive ? 'background-color: rgba(255, 193, 7, 0.1);' : ''}">
                                    <td style="font-size: 0.85rem;">${formatTime(req.timestamp).replace(/:\d{2}$/, '')}</td>
                                    <td style="max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${req.url}">
                                        ${req.url}
                                    </td>
                                    <td style="text-align: center;">
                                        <span style="color: ${serviceColor}; font-weight: bold; font-size: 0.8rem;">${serviceType}</span>
                                    </td>
                                    <td>
                                        <span class="status-badge ${statusClass}">${statusDisplay}</span>
                                    </td>
                                    <td style="font-family: monospace; font-size: 0.75rem;" title="${req.token}">
                                        ${truncatedToken ? `<span style="background: #f8f9fa; padding: 2px 4px; border-radius: 3px; border: 1px solid #dee2e6;">${truncatedToken}</span>` : '-'}
                                    </td>
                                    <td style="font-weight: ${req.isActive ? 'bold' : 'normal'};">
                                        ${responseTimeDisplay}
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
                <div style="margin-top: 10px; font-size: 0.85rem; color: #6c757d; text-align: center;">
                    æ˜¾ç¤ºæœ€è¿‘ ${Math.min(allRequests.length, 50)} æ¡è®°å½•
                    ${allRequests.length > 50 ? `ï¼ˆå…± ${allRequests.length} æ¡ï¼‰` : ''}
                </div>
            `;
            
            element.innerHTML = tableHTML;
        }

        // é‡ç½®ç›‘æ§æ•°æ®
        async function resetMonitorData() {
            if (!confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰ç›‘æ§æ•°æ®å—ï¼Ÿ')) return;
            
            try {
                const response = await fetch('/api/monitor/reset', { method: 'POST' });
                if (response.ok) {
                    // é‡ç½®æœ¬åœ°æ•°æ®
                    loadHistory = [];
                    peakConcurrent = 0;
                    if (loadChart) {
                        loadChart.clear();
                    }
                    alert('ç›‘æ§æ•°æ®å·²é‡ç½®');
                    fetchMonitorData();
                } else {
                    throw new Error('é‡ç½®å¤±è´¥');
                }
            } catch (error) {
                alert('é‡ç½®å¤±è´¥: ' + error.message);
            }
        }

        // å¯åŠ¨ç›‘æ§
        function startMonitoring() {
            fetchMonitorData(); // ç«‹å³è·å–ä¸€æ¬¡æ•°æ®
            updateInterval = setInterval(fetchMonitorData, 1000); // æ¯1ç§’æ›´æ–°ä¸€æ¬¡
        }

        // åœæ­¢ç›‘æ§
        function stopMonitoring() {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
        }

        // æ›´æ–°è´Ÿè½½æŒ‡æ ‡
        function updateLoadMetrics(data) {
            const currentActive = data.requests.active;
            const totalCapacity = data.instances.total;
            
            // æ›´æ–°å³°å€¼å¹¶å‘
            peakConcurrent = Math.max(peakConcurrent, currentActive);
            
            // è®°å½•è´Ÿè½½å†å²
            loadHistory.push(currentActive);
            if (loadHistory.length > 60) {
                loadHistory.shift();
            }
            
            // è®¡ç®—å¹³å‡è´Ÿè½½
            const avgLoad = loadHistory.length > 0 ? 
                loadHistory.reduce((sum, val) => sum + val, 0) / loadHistory.length : 0;
            
            // æ›´æ–°æ±‡æ€»æŒ‡æ ‡
            document.getElementById('currentActive').textContent = currentActive;
            document.getElementById('peakConcurrent').textContent = peakConcurrent;
            document.getElementById('avgLoad').textContent = avgLoad.toFixed(1);
            document.getElementById('totalCapacity').textContent = totalCapacity;
        }
        
        // æ›´æ–°å›¾è¡¨
        function updateCharts(data) {
            if (loadChart) {
                const currentActive = data.requests.active;
                const now = new Date();
                loadChart.addData(currentActive, now);
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨ç›‘æ§
        document.addEventListener('DOMContentLoaded', () => {
            // å»¶è¿Ÿåˆå§‹åŒ–å›¾è¡¨ï¼Œç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
            setTimeout(() => {
                initCharts();
                startMonitoring();
            }, 100);
        });

        // çª—å£å¤§å°è°ƒæ•´æ—¶é‡æ–°è°ƒæ•´å›¾è¡¨
        window.addEventListener('resize', () => {
            if (loadChart) {
                loadChart.resize();
            }
        });

        // é¡µé¢ç¦»å¼€æ—¶åœæ­¢ç›‘æ§
        window.addEventListener('beforeunload', stopMonitoring);
        
        // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶æ§åˆ¶ç›‘æ§
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopMonitoring();
            } else {
                startMonitoring();
            }
        });
        
        // ç»˜åˆ¶åŒæŠ˜çº¿å›¾è¡¨å‡½æ•°
        function drawDualLineChart(canvasId, data1, data2, color1, color2) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            if (data1.length < 2 || data2.length < 2) return;
            
            // è®¾ç½®ç”»å¸ƒå¤§å°é€‚åº”å®¹å™¨ - æ”¯æŒé«˜DPI
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            ctx.scale(dpr, dpr);
            
            const w = rect.width;
            const h = rect.height;
            
            // ä¸ºå·¦å³åˆ»åº¦ç•™å‡ºç´§å‡‘ç©ºé—´
            const leftPadding = 25;   // å·¦ä¾§æ´»è·ƒè¯·æ±‚åˆ»åº¦
            const rightPadding = 35;  // å³ä¾§æˆåŠŸç‡åˆ»åº¦
            const topPadding = 25;    // ä¸Šæ–¹ç»Ÿè®¡ä¿¡æ¯
            const bottomPadding = 15; // åº•éƒ¨è¾¹è·
            const chartWidth = w - leftPadding - rightPadding;
            const chartHeight = h - topPadding - bottomPadding;
            
            // è·å–æ•°æ®èŒƒå›´
            const maxData1 = Math.max(...data1, 1);
            const maxData2 = 100; // æˆåŠŸç‡æœ€å¤§100%
            
            // ç»˜åˆ¶ç¬¬ä¸€æ¡çº¿ï¼ˆæ´»è·ƒè¯·æ±‚ï¼‰
            if (data1.length >= 2) {
                ctx.beginPath();
                
                // ç»˜åˆ¶æ•°æ®ç‚¹å’Œçº¿æ¡
                for (let i = 0; i < data1.length; i++) {
                    const x = leftPadding + (i / (data1.length - 1)) * chartWidth;
                    const y = topPadding + (1 - (data1[i] / maxData1)) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        // ä½¿ç”¨è´å¡å°”æ›²çº¿åˆ›å»ºå¹³æ»‘çº¿æ¡
                        const prevX = leftPadding + ((i - 1) / (data1.length - 1)) * chartWidth;
                        const prevY = topPadding + (1 - (data1[i - 1] / maxData1)) * chartHeight;
                        
                        const cpx = prevX + (x - prevX) * 0.5;
                        const cpy = prevY;
                        const cpx2 = prevX + (x - prevX) * 0.5;
                        const cpy2 = y;
                        
                        ctx.bezierCurveTo(cpx, cpy, cpx2, cpy2, x, y);
                    }
                }
                
                // ç»˜åˆ¶å¡«å……åŒºåŸŸï¼ˆæ´»è·ƒè¯·æ±‚ï¼‰
                const fillPath1 = new Path2D();
                fillPath1.moveTo(leftPadding, h - bottomPadding); // åº•éƒ¨å·¦è¾¹
                
                for (let i = 0; i < data1.length; i++) {
                    const x = leftPadding + (i / (data1.length - 1)) * chartWidth;
                    const y = topPadding + (1 - (data1[i] / maxData1)) * chartHeight;
                    
                    if (i === 0) {
                        fillPath1.lineTo(x, y);
                    } else {
                        const prevX = leftPadding + ((i - 1) / (data1.length - 1)) * chartWidth;
                        const prevY = topPadding + (1 - (data1[i - 1] / maxData1)) * chartHeight;
                        
                        const cpx = prevX + (x - prevX) * 0.5;
                        const cpy = prevY;
                        const cpx2 = prevX + (x - prevX) * 0.5;
                        const cpy2 = y;
                        
                        fillPath1.bezierCurveTo(cpx, cpy, cpx2, cpy2, x, y);
                    }
                }
                
                fillPath1.lineTo(leftPadding + chartWidth, h - bottomPadding); // åº•éƒ¨å³è¾¹
                fillPath1.closePath();
                
                // å¡«å……åŒºåŸŸ
                const gradient1 = ctx.createLinearGradient(0, topPadding, 0, h - bottomPadding);
                gradient1.addColorStop(0, color1 + '30'); // 30% é€æ˜åº¦ï¼ˆé™ä½é€æ˜åº¦é¿å…é®æŒ¡æ–‡å­—ï¼‰
                gradient1.addColorStop(1, color1 + '05'); // 5% é€æ˜åº¦
                ctx.fillStyle = gradient1;
                ctx.fill(fillPath1);
                
                // ç»˜åˆ¶çº¿æ¡
                ctx.strokeStyle = color1;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            }
            
            // ç»˜åˆ¶ç¬¬äºŒæ¡çº¿ï¼ˆæˆåŠŸç‡ï¼‰
            if (data2.length >= 2) {
                ctx.beginPath();
                
                // ç»˜åˆ¶æ•°æ®ç‚¹å’Œçº¿æ¡
                for (let i = 0; i < data2.length; i++) {
                    const x = leftPadding + (i / (data2.length - 1)) * chartWidth;
                    const y = topPadding + (1 - (data2[i] / maxData2)) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        // ä½¿ç”¨è´å¡å°”æ›²çº¿åˆ›å»ºå¹³æ»‘çº¿æ¡
                        const prevX = leftPadding + ((i - 1) / (data2.length - 1)) * chartWidth;
                        const prevY = topPadding + (1 - (data2[i - 1] / maxData2)) * chartHeight;
                        
                        const cpx = prevX + (x - prevX) * 0.5;
                        const cpy = prevY;
                        const cpx2 = prevX + (x - prevX) * 0.5;
                        const cpy2 = y;
                        
                        ctx.bezierCurveTo(cpx, cpy, cpx2, cpy2, x, y);
                    }
                }
                
                // ç»˜åˆ¶çº¿æ¡ï¼ˆä¸å¡«å……ï¼Œé¿å…ä¸ç¬¬ä¸€æ¡çº¿å†²çªï¼‰
                ctx.strokeStyle = color2;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            }
        }
    </script>
</body>
</html>